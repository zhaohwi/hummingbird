use std::env;

use tracing::{debug, info, warn};

use crate::devices::{
    errors::{
        CloseError, FindError, InfoError, InitializationError, ListError, OpenError, StateError,
    },
    format::{BufferSize, ChannelSpec, FormatInfo, SampleFormat, SupportedFormat},
    traits::{Device, DeviceProvider, OutputStream},
};

/// The dummy device provider is provided for testing purposes. It does not play any actual audio,
/// and submitting samples to devices generated by this provider is a no-op.
///
/// This streams provided by this device provider will never block when samples are submitted,
/// meaning that the playback thread will likely submit the next samples immediately.
///
/// The following environment variables can be used to configure the dummy device:
/// - `HB_DUMMY_SAMPLE_RATE`: The sample rate of the dummy device. Defaults to 44100.
/// - `HB_DUMMY_BIT_FORMAT`: The bit format of the dummy device. Defaults to `S16`.
/// - `HB_DUMMY_CHANNELS`: The number of channels of the dummy device. Defaults to 2.
/// - `HB_DUMMY_BUFFER_SIZE`: The buffer size of the dummy device. Defaults to 4096.
///   - This doesn't actually do anything: no samples are ever loaded into a buffer.
pub struct DummyDeviceProvider {}

impl DummyDeviceProvider {
    pub fn new() -> Self {
        Self {}
    }
}

impl DeviceProvider for DummyDeviceProvider {
    fn initialize(&mut self) -> Result<(), InitializationError> {
        info!("DummyDeviceProvider initialized");
        warn!("This device provider WILL not play any actual audio.");
        Ok(())
    }

    fn get_devices(&mut self) -> Result<Vec<Box<dyn Device>>, ListError> {
        debug!("Listing dummy devices");
        Ok(vec![])
    }

    fn get_default_device(&mut self) -> Result<Box<dyn Device>, FindError> {
        debug!("Creating new dummy device");
        Ok(Box::new(DummyDevice {}) as Box<dyn Device>)
    }

    fn get_device_by_uid(&mut self, _: &str) -> Result<Box<dyn Device>, FindError> {
        Err(FindError::DeviceDoesNotExist)
    }
}

pub struct DummyDevice {}

impl DummyDevice {
    pub fn get_sample_rate() -> u32 {
        env::var("HB_DUMMY_SAMPLE_RATE")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(44100)
    }

    pub fn get_bit_format() -> SampleFormat {
        let string = env::var("HB_DUMMY_BIT_FORMAT")
            .ok()
            .unwrap_or("S16".to_string());

        match string.as_str() {
            "F64" => SampleFormat::Float64,
            "F32" => SampleFormat::Float32,
            "S32" => SampleFormat::Signed32,
            "U32" => SampleFormat::Unsigned32,
            "S24" => SampleFormat::Signed24,
            "U24" => SampleFormat::Unsigned24,
            "S16" => SampleFormat::Signed16,
            "U16" => SampleFormat::Unsigned16,
            "S8" => SampleFormat::Signed8,
            "U8" => SampleFormat::Unsigned8,
            "DSD" => SampleFormat::Dsd,
            _ => SampleFormat::Unsupported,
        }
    }

    pub fn get_channels() -> u16 {
        env::var("HB_DUMMY_CHANNELS")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(2)
    }

    pub fn get_buffer_size() -> u32 {
        env::var("HB_DUMMY_BUFFER_SIZE")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(4096)
    }
}

impl Device for DummyDevice {
    fn open_device(&mut self, format: FormatInfo) -> Result<Box<dyn OutputStream>, OpenError> {
        let device = DummyStream { format };
        Ok(Box::new(device) as Box<dyn OutputStream>)
    }

    fn get_supported_formats(&self) -> Result<Vec<SupportedFormat>, InfoError> {
        Ok(vec![SupportedFormat {
            originating_provider: "dummy",
            sample_type: DummyDevice::get_bit_format(),
            sample_rates: (
                DummyDevice::get_sample_rate(),
                DummyDevice::get_sample_rate(),
            ),
            buffer_size: BufferSize::Fixed(DummyDevice::get_buffer_size()),
            channels: ChannelSpec::Count(DummyDevice::get_channels()),
        }])
    }

    fn get_default_format(&self) -> Result<FormatInfo, InfoError> {
        Ok(FormatInfo {
            originating_provider: "dummy",
            sample_type: DummyDevice::get_bit_format(),
            sample_rate: DummyDevice::get_sample_rate(),
            buffer_size: BufferSize::Fixed(DummyDevice::get_buffer_size()),
            channels: ChannelSpec::Count(DummyDevice::get_channels()),
            rate_channel_ratio: Some(2),
        })
    }

    fn get_name(&self) -> Result<String, InfoError> {
        Ok("Hummingbird Dummy Audio Device".to_string())
    }

    fn get_uid(&self) -> Result<String, InfoError> {
        Ok("dummy".to_string())
    }

    fn requires_matching_format(&self) -> bool {
        true
    }
}

pub struct DummyStream {
    pub format: FormatInfo,
}

impl OutputStream for DummyStream {
    fn submit_frame(
        &mut self,
        frame: crate::media::playback::PlaybackFrame,
    ) -> Result<(), crate::devices::errors::SubmissionError> {
        debug!("Frame received! Sample rate: {}", frame.rate);
        Ok(())
    }

    fn close_stream(&mut self) -> Result<(), CloseError> {
        debug!("Stream closed.");
        Ok(())
    }

    fn needs_input(&self) -> bool {
        true
    }

    fn get_current_format(&self) -> Result<&FormatInfo, InfoError> {
        Ok(&self.format)
    }

    fn play(&mut self) -> Result<(), StateError> {
        debug!("Stream resumed.");
        Ok(())
    }

    fn pause(&mut self) -> Result<(), StateError> {
        debug!("Stream paused.");
        Ok(())
    }

    fn reset(&mut self) -> Result<(), crate::devices::errors::ResetError> {
        debug!("Stream reset.");
        Ok(())
    }

    fn set_volume(&mut self, volume: f64) -> Result<(), StateError> {
        debug!("Volume set to {}.", volume);
        Ok(())
    }
}
